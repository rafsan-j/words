<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Vocabulary Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        /* Base Light Theme */
        :root {
            --bg-page: #f7f9fb;
            --bg-container: #ffffff;
            --text-primary: #1f2937; /* Gray 900 */
            --text-secondary: #6b7280; /* Gray 500 */
            --border-color: #e5e7eb; /* Gray 200 */
            --card-front-bg-start: #ffffff;
            --card-front-bg-end: #f0f4f8;
            --card-back-bg-start: #e6efff;
            --card-back-bg-end: #d5e3ff;
            --card-border: #e0e6ed;
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --input-bg: #ffffff;
        }

        /* Dark Mode Overrides */
        [data-theme='dark'] {
            --bg-page: #1f2937; /* Dark Gray */
            --bg-container: #374151; /* Medium Dark Gray */
            --text-primary: #f9fafb; /* White */
            --text-secondary: #9ca3af; /* Gray 400 */
            --border-color: #4b5563; /* Gray 600 */
            --card-front-bg-start: #4b5563;
            --card-front-bg-end: #374151;
            --card-back-bg-start: #2563eb; /* Blue 600 */
            --card-back-bg-end: #1d4ed8; /* Blue 700 */
            --card-border: #4b5563;
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            --input-bg: #4b5563;
        }

        /* Responsive Layout Optimization */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-page);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Start items at top (prevents excessive centering on long mobile content) */
            min-height: 100vh;
            padding: 20px 10px; /* Reduced horizontal padding for mobile */
            transition: background-color 0.3s;
        }
        .container-main {
            width: 100%;
            max-width: 900px;
            padding-top: 20px; /* Add vertical padding */
            padding-bottom: 20px;
        }
        
        /* Mobile Specific Adjustments */
        @media (max-width: 640px) {
             body {
                /* On small screens, allow content to flow naturally, setting min-height to initial */
                min-height: initial; 
                display: block; /* Use block flow on small screens */
                padding: 10px; /* Uniform smaller padding */
            }
            .container-main {
                margin: 0 auto; /* Center block element */
                padding-top: 0;
            }
        }
        
        /* General Component Dark Mode Styling */
        .p-6 {
            background-color: var(--bg-container);
            border-color: var(--border-color);
        }
        
        /* Flashcard Styling */
        .card-container {
            perspective: 1000px;
            width: 100%;
            max-width: 600px;
            height: 350px;
            margin: 0 auto;
        }
        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
        }
        .flashcard.flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 1rem;
            box-shadow: var(--shadow);
            padding: 2rem;
            text-align: center;
            border: 1px solid var(--card-border);
        }
        .card-front {
            background: linear-gradient(145deg, var(--card-front-bg-start), var(--card-front-bg-end));
        }
        .card-back {
            background: linear-gradient(145deg, var(--card-back-bg-start), var(--card-back-bg-end));
            transform: rotateY(180deg);
        }
        .btn-mark.selected {
            border: 3px solid;
        }
        
        /* Quiz Styling */
        .quiz-option {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.05);
        }
        .quiz-option:hover {
            background-color: var(--bg-page);
        }

        /* Input Styling */
        input[type="text"], textarea {
            background-color: var(--input-bg);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        /* QR Code Container (Specific Dark Mode fix for white background) */
        #qrcode-container > div {
            background-color: white;
            padding: 10px;
            border-radius: 8px;
        }

        /* Mobile Optimization: Swiping feedback */
        .swiping-up { border: 3px solid #10b981; }
        .swiping-down { border: 3px solid #f97316; }
        .swiping-left, .swiping-right { border: 3px solid #3b82f6; }


        /* Tailwind class updates for Dark Mode compatibility */
        [data-theme='dark'] .text-gray-800 { color: #f9fafb; }
        [data-theme='dark'] .text-gray-900 { color: #f9fafb; }
        [data-theme='dark'] .text-gray-600 { color: #d1d5db; }
        [data-theme='dark'] .text-gray-500 { color: #9ca3af; }
        [data-theme='dark'] .bg-gray-100 { background-color: #374151; }
        [data-theme='dark'] .bg-white { background-color: #374151; }
        [data-theme='dark'] .border-gray-200 { border-color: #4b5563; }
        [data-theme='dark'] .bg-gray-50 { background-color: #4b5563; }
        [data-theme='dark'] .shadow-inner { box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.6); }

    </style>
</head>
<body data-theme="light">

    <div class="flex flex-col items-center w-full max-w-4xl container-main">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Offline Vocabulary Master</h1>

        <p id="user-status" class="text-sm text-blue-600 font-semibold mb-4 text-center">
            Mode: Offline (Progress saved in browser's local storage).
        </p>

        <div class="flex flex-wrap justify-center gap-2 p-2 bg-gray-100 rounded-xl mb-8 shadow-inner w-full max-w-full sm:rounded-full sm:p-1 sm:gap-0 sm:flex-nowrap">
            <button id="mode-flashcard" onclick="setMode('flashcard')"
                class="px-3 py-2 text-sm font-semibold rounded-lg sm:rounded-full transition duration-150 flex-grow sm:flex-grow-0">
                üìö Flashcards
            </button>
            <button id="mode-quiz" onclick="setMode('quiz')"
                class="px-3 py-2 text-sm font-semibold rounded-lg sm:rounded-full transition duration-150 flex-grow sm:flex-grow-0">
                ‚ùì Take Quiz <span id="quiz-due-count" class="ml-1 px-2 py-0.5 text-xs font-bold rounded-full bg-red-500 text-white hidden"></span>
            </button>
            <button id="mode-review" onclick="setMode('review')"
                class="px-3 py-2 text-sm font-semibold rounded-lg sm:rounded-full transition duration-150 flex-grow sm:flex-grow-0">
                üî• Review Hard Words
            </button>
            <button id="mode-manage" onclick="setMode('manage')"
                class="px-3 py-2 text-sm font-semibold rounded-lg sm:rounded-full transition duration-150 flex-grow sm:flex-grow-0">
                ‚ûï Word Manager
            </button>
            <button id="mode-settings" onclick="setMode('settings')"
                class="px-3 py-2 text-sm font-semibold rounded-lg sm:rounded-full transition duration-150 flex-grow sm:flex-grow-0">
                ‚öôÔ∏è Settings
            </button>
        </div>

        <div id="flashcard-mode" class="w-full">
            <div class="card-container mb-6">
                <div id="flashcard" class="flashcard" onclick="flipCard()">
                    <div class="card-face card-front">
                        <span class="text-sm font-medium text-blue-500 uppercase mb-2" id="card-tag-front"></span>
                        <h2 class="text-5xl font-extrabold text-gray-900" id="card-word"></h2>
                        <p class="text-sm text-gray-500 mt-4">(Click/tap to reveal meaning, swipe for mobile controls)</p>
                        <p id="card-deck-status" class="text-xs text-gray-400 mt-4"></p>
                    </div>
                    <div class="card-face card-back">
                        <span class="text-sm font-medium text-blue-700 uppercase mb-2">Meaning</span>
                        <p class="text-xl font-semibold text-gray-800" id="card-meaning"></p>
                        <div class="mt-4 flex items-center justify-center space-x-3 text-sm text-gray-500">
                             <span id="wrong-count" class="text-red-500 font-semibold"></span>
                            <span>(Click to see word)</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="w-full max-w-xl mx-auto mb-6 p-4 bg-white rounded-xl shadow-md border border-gray-100">
                <h4 class="text-lg font-bold text-gray-800 mb-3 text-center">Mark Difficulty (For SRS Scheduling)</h4>
                <div class="flex flex-wrap justify-center gap-3">
                    <button onclick="markDifficulty('easy')" id="mark-easy"
                        class="btn-mark flex-1 min-w-[100px] py-2 text-sm font-semibold rounded-full bg-green-200 text-green-800 hover:bg-green-300">
                        Easy (7 Days)
                    </button>
                    <button onclick="markDifficulty('hard')" id="mark-hard"
                        class="btn-mark flex-1 min-w-[100px] py-2 text-sm font-semibold rounded-full bg-yellow-200 text-yellow-800 hover:bg-yellow-300">
                        Hard (3 Days)
                    </button>
                    <button onclick="markDifficulty('superhard')" id="mark-superhard"
                        class="btn-mark flex-1 min-w-[100px] py-2 text-sm font-semibold rounded-full bg-red-200 text-red-800 hover:bg-red-300">
                        Super Hard (1 Day)
                    </button>
                </div>
            </div>

            <div class="flex space-x-4 mb-8 justify-center">
                <button id="prevBtn" onclick="navigateCard(-1)"
                    class="px-6 py-3 bg-gray-200 text-gray-800 font-semibold rounded-full hover:bg-gray-300 transition duration-150 shadow-md dark:bg-gray-600 dark:text-gray-100 dark:hover:bg-gray-700">
                    &larr; Previous
                </button>
                <button id="nextBtn" onclick="navigateCard(1)"
                    class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-full hover:bg-blue-700 transition duration-150 shadow-lg">
                    Next Word &rarr;
                </button>
            </div>

            <div class="w-full max-w-xl mx-auto p-4 bg-gray-100 border border-gray-300 rounded-lg text-sm text-gray-600 text-center">
                This is the offline version. Progress is saved locally in your browser.
            </div>
        </div>

        <div id="quiz-mode" class="hidden w-full max-w-xl mx-auto">
            <div class="p-6 bg-white rounded-xl shadow-lg border border-gray-200">
                <div class="flex flex-wrap items-center justify-center p-3 mb-4 bg-gray-50 rounded-lg">
                    <span class="mr-4 text-sm font-semibold text-gray-700 min-w-full text-center sm:min-w-0 sm:text-left">Quiz Type:</span>
                    <label class="flex items-center space-x-2 mr-4 cursor-pointer mt-2 sm:mt-0">
                        <input type="radio" name="quiz_type" value="recognition" checked onclick="setQuizType('recognition')"
                               class="text-blue-600 focus:ring-blue-500">
                        <span class="text-sm font-medium text-gray-700">Recognition (MCQ)</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer mt-2 sm:mt-0">
                        <input type="radio" name="quiz_type" value="recall" onclick="setQuizType('recall')"
                               class="text-blue-600 focus:ring-blue-500">
                        <span class="text-sm font-medium text-gray-700">Recall (Type In)</span>
                    </label>
                </div>
                
                <p id="quiz-status" class="text-sm text-blue-600 font-semibold mb-3">Quiz Status</p>

                <div id="quiz-question-container" class="mb-6">
                    <h2 class="text-3xl font-bold text-gray-900" id="quiz-word"></h2>
                    <p class="text-xl font-semibold text-gray-800 hidden" id="quiz-meaning-recall"></p>
                    <p class="text-sm text-gray-500 mt-1 hidden" id="quiz-prompt-recall">Type the word that matches the definition:</p>
                </div>

                <div id="quiz-answer-area">
                    <div id="quiz-options" class="space-y-3"></div>

                    <div id="recall-input-container" class="hidden space-y-3">
                        <input type="text" id="recall-input" placeholder="Type the word here..."
                               class="w-full p-3 border border-gray-300 rounded-lg text-lg focus:ring-blue-500 focus:border-blue-500"
                               onkeydown="if(event.key==='Enter') checkRecallAnswer()">
                        <button id="recall-check-btn" onclick="checkRecallAnswer()"
                                class="w-full px-6 py-3 bg-green-600 text-white font-semibold rounded-full hover:bg-green-700 transition duration-150 shadow-md">
                            Check Answer
                        </button>
                        <div id="recall-feedback" class="pt-2"></div>
                    </div>
                </div>

                <button id="nextQuizBtn" onclick="loadQuizWord()"
                    class="mt-6 w-full px-6 py-3 bg-blue-600 text-white font-semibold rounded-full hover:bg-blue-700 transition duration-150 shadow-lg hidden">
                    Next Question &rarr;
                </button>
            </div>
        </div>

        <div id="review-mode" class="hidden w-full max-w-xl mx-auto">
            <div class="p-6 bg-white rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">Words to Review</h2>
                <div class="flex flex-wrap gap-3 mb-4 text-sm font-medium">
                    <button onclick="filterReview('hard')" id="filter-hard" class="px-3 py-1 rounded-full bg-yellow-100 text-yellow-800 hover:bg-yellow-200">
                        Hard
                    </button>
                    <button onclick="filterReview('superhard')" id="filter-superhard" class="px-3 py-1 rounded-full bg-red-100 text-red-800 hover:bg-red-200">
                        Super Hard
                    </button>
                    <button onclick="filterReview('missed')" id="filter-missed" class="px-3 py-1 rounded-full bg-red-500 text-white hover:bg-red-600">
                        Missed in Quiz
                    </button>
                </div>
                <div id="review-list" class="space-y-2 text-sm max-h-96 overflow-y-auto">
                    <p class="text-gray-500" id="review-placeholder">Select a filter to see words for review.</p>
                </div>
            </div>
        </div>

        <div id="manage-mode" class="hidden w-full max-w-xl mx-auto">
            <div class="p-6 bg-white rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">‚ûï Word Manager</h2>
                
                <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">1. Import New Vocabulary (JSON Array)</h3>
                <p class="text-gray-600 mb-2 text-sm">
                    Paste a JSON array below to add new words.
                </p>
                <textarea id="word-input-area" rows="4" placeholder='[
  {"word": "newword", "meaning": "the meaning", "tag": "category"},
  {"word": "another", "meaning": "another meaning", "tag": "category"}
]' class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 font-mono text-xs"></textarea>

                <button onclick="addWordsFromJson()"
                    class="mt-2 w-full px-6 py-3 bg-green-600 text-white font-semibold rounded-full hover:bg-green-700 transition duration-150 shadow-lg">
                    Import & Save New Words
                </button>
                
                <hr class="my-6 border-gray-300">

                <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">2. Sync Progress (Two-Way QR)</h3>

                <button onclick="showSyncModal('export')"
                    class="w-full px-6 py-3 bg-blue-600 text-white font-semibold rounded-full hover:bg-blue-700 transition duration-150 shadow-lg mb-3">
                    üì§ Export & Generate QR Code (Source)
                </button>

                <p class="text-gray-600 mb-2 text-sm">
                    Or paste the full sync data (from a scanned QR code) below to update this device.
                </p>
                <textarea id="sync-import-area" rows="4" placeholder='Paste compressed data here...' 
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 font-mono text-xs"></textarea>
                
                <button onclick="importSyncDataFromTextarea()"
                    class="mt-2 w-full px-6 py-3 bg-purple-600 text-white font-semibold rounded-full hover:bg-purple-700 transition duration-150 shadow-lg">
                    üì• Import & Update All Data (Target)
                </button>

                <div id="word-manager-status" class="mt-4 p-3 bg-gray-100 border border-gray-200 rounded-lg text-sm text-gray-700 flex justify-between items-center">
                    <span>Total Words Loaded: <span id="total-words-count" class="font-bold">0</span></span>
                    <button onclick="showClearDataModal()" 
                        class="px-3 py-1 bg-red-500 text-white font-semibold rounded-full text-xs hover:bg-red-600 transition duration-150">
                        Clear All Data
                    </button>
                </div>
            </div>
        </div>

        <div id="settings-mode" class="hidden w-full max-w-xl mx-auto">
             <div class="p-6 bg-white rounded-xl shadow-lg border border-gray-200 space-y-6">
                <h2 class="text-2xl font-bold text-gray-900 mb-4">‚öôÔ∏è User Settings</h2>
                
                <div class="flex items-center justify-between p-4 border border-gray-200 rounded-lg">
                    <span class="text-lg font-semibold text-gray-800">Toggle Dark Mode</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="dark-mode-toggle" class="sr-only peer" onchange="toggleDarkMode(this.checked)">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                        <span id="dark-mode-label" class="ml-3 text-sm font-medium text-gray-900">Light</span>
                    </label>
                </div>

                <h3 class="text-xl font-bold text-gray-900 mt-6">Quiz Settings</h3>
                <div class="flex items-center justify-between p-4 border border-gray-200 rounded-lg">
                    <span class="text-lg font-semibold text-gray-800">Include "Easy" Words in Quiz</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="include-easy-toggle" class="sr-only peer" onchange="toggleIncludeEasy(this.checked)">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                    </label>
                </div>
                <h3 class="text-xl font-bold text-gray-900 mt-6">Mobile Swipe Actions (Flashcards)</h3>
                <p class="text-sm text-gray-600 italic">Horizontal swipes are fixed (Left=Prev, Right=Next). Customize vertical swipes:</p>
                
                <div class="space-y-4">
                    <div class="flex flex-wrap items-center justify-between p-3 border border-gray-200 rounded-lg">
                        <label for="swipe-up-action" class="font-medium text-gray-800 mb-2 w-full sm:w-auto sm:mb-0">Swipe Up Action:</label>
                        <select id="swipe-up-action" onchange="saveSettings()" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg block w-full sm:w-1/2 p-2.5">
                            <option value="easy">Easy (7 Days)</option>
                            <option value="hard">Hard (3 Days)</option>
                            <option value="superhard">Super Hard (1 Day)</option>
                        </select>
                    </div>
                    
                    <div class="flex flex-wrap items-center justify-between p-3 border border-gray-200 rounded-lg">
                        <label for="swipe-down-action" class="font-medium text-gray-800 mb-2 w-full sm:w-auto sm:mb-0">Swipe Down Action:</label>
                        <select id="swipe-down-action" onchange="saveSettings()" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg block w-full sm:w-1/2 p-2.5">
                            <option value="hard">Hard (3 Days)</option>
                            <option value="easy">Easy (7 Days)</option>
                            <option value="superhard">Super Hard (1 Day)</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div id="errorMessage" class="hidden fixed bottom-5 left-1/2 -translate-x-1/2 p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg text-sm shadow-xl z-50" role="alert"></div>

    </div>

    <div id="clearDataModal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Confirm Data Deletion</h3>
            <p class="text-gray-600 mb-6">Are you sure you want to delete **ALL** vocabulary and progress data? This action cannot be undone.</p>
            <div class="flex justify-end space-x-3">
                <button onclick="hideClearDataModal()" class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-full hover:bg-gray-300">
                    Cancel
                </button>
                <button onclick="clearAllDataConfirmed()" class="px-4 py-2 bg-red-600 text-white font-semibold rounded-full hover:bg-red-700">
                    Yes, Delete All
                </button>
            </div>
        </div>
    </div>

    <div id="syncModal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-gray-800 mb-4" id="sync-modal-title">Export Data via QR Code</h3>
            
            <div id="sync-export-view">
                <p class="text-gray-600 mb-4 text-sm">
                    Scan this QR code with your target device's camera app to transfer ALL words and progress data.
                    <span class="font-bold text-red-600 block mt-1">IMPORTANT:</span> The QR text must be copied and pasted into the "Import" area on the other device.
                </p>
                <div id="qrcode-container" class="flex justify-center my-6">
                    </div>
                <div class="mt-4 p-2 bg-gray-100 border border-gray-200 text-xs text-gray-700 break-words max-h-24 overflow-y-auto">
                    Data size: <span id="sync-data-size">0 bytes</span> (Compressed)
                </div>
                <p class="text-center mt-3 text-sm text-gray-500">Close this modal when done scanning.</p>
            </div>

            <div class="flex justify-end mt-4">
                <button onclick="hideSyncModal()" class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-full hover:bg-gray-300">
                    Done
                </button>
            </div>
        </div>
    </div>

    <style>
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: var(--bg-container);
            margin: 5% auto;
            padding: 20px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 500px;
            border-radius: 12px;
            box-shadow: var(--shadow);
        }
        /* Quiz Answer Styling */
        .correct-answer {
            background-color: #d1fae5; /* Green 100 */
            border-color: #34d399; /* Green 400 */
        }
        .wrong-answer {
            background-color: #fee2e2; /* Red 100 */
            border-color: #f87171; /* Red 400 */
        }
        [data-theme='dark'] .correct-answer {
            background-color: #065f46; /* Green 800 */
            border-color: #34d399;
        }
        [data-theme='dark'] .wrong-answer {
            background-color: #991b1b; /* Red 800 */
            border-color: #f87171;
        }
        .recall-result-correct {
            color: #10b981; /* Green 500 */
        }
        .recall-result-wrong {
            color: #ef4444; /* Red 500 */
        }

    </style>
    <script>
        // --- CONSTANTS ---
        const PROGRESS_STORAGE_KEY = 'vocabAppProgress';
        const VOCAB_STORAGE_KEY = 'vocabAppWords';
        const SETTINGS_STORAGE_KEY = 'vocabAppSettings';
        const SWIPE_THRESHOLD = 75; // Increased sensitivity for easier swiping

        // --- Default Settings ---
        const defaultSettings = {
            darkMode: false,
            swipeUp: 'easy',
            swipeDown: 'hard',
            includeEasyInQuiz: false 
        };

        // --- Global State ---
        let vocabularyWords = [];
        let wordProgress = {};
        let flashcardDeckIndices = [];
        let currentWordIndex = 0;
        let isFlipped = false;
        let currentMode = 'flashcard';
        let currentQuizWord = null;
        let currentQuizType = 'recognition';
        let userSettings = defaultSettings;
        let touchStartX = 0;
        let touchStartY = 0;


        // --- DOM Elements ---
        const flashcardEl = document.getElementById('flashcard');
        const cardWordEl = document.getElementById('card-word');
        const cardMeaningEl = document.getElementById('card-meaning');
        const cardTagFrontEl = document.getElementById('card-tag-front');
        const cardDeckStatusEl = document.getElementById('card-deck-status');
        const wrongCountEl = document.getElementById('wrong-count');
        const errorEl = document.getElementById('errorMessage');
        const totalWordsCountEl = document.getElementById('total-words-count');
        const quizDueCountEl = document.getElementById('quiz-due-count');
        const clearDataModalEl = document.getElementById('clearDataModal');
        const syncModalEl = document.getElementById('syncModal');
        const qrCodeContainerEl = document.getElementById('qrcode-container'); 

        // Quiz DOM Elements
        const quizWordEl = document.getElementById('quiz-word');
        const quizMeaningRecallEl = document.getElementById('quiz-meaning-recall');
        const quizPromptRecallEl = document.getElementById('quiz-prompt-recall');
        const quizOptionsEl = document.getElementById('quiz-options');
        const recallInputContainerEl = document.getElementById('recall-input-container');
        const recallInputEl = document.getElementById('recall-input');
        const recallCheckBtnEl = document.getElementById('recall-check-btn');
        const recallFeedbackEl = document.getElementById('recall-feedback');
        const nextQuizBtn = document.getElementById('nextQuizBtn');
        const markButtons = {
            easy: document.getElementById('mark-easy'),
            hard: document.getElementById('mark-hard'),
            superhard: document.getElementById('mark-superhard')
        };
        const modeButtons = {
            flashcard: document.getElementById('mode-flashcard'),
            quiz: document.getElementById('mode-quiz'),
            review: document.getElementById('mode-review'),
            manage: document.getElementById('mode-manage'),
            settings: document.getElementById('mode-settings')
        };

        // --- Data Serialization / QR Sync Logic --- 
        /**
         * Compresses and encodes the combined data for QR transfer.
         * @returns {string} Base64-encoded compressed JSON string.
         */
        function exportDataToJSON() {
            const data = { vocab: vocabularyWords, progress: wordProgress };
            const jsonString = JSON.stringify(data);
            // 1. Convert string to Uint8Array
            const dataBytes = new TextEncoder().encode(jsonString);
            // 2. Compress using Pako (zlib/gzip)
            const compressed = pako.deflate(dataBytes);
            // 3. Convert Uint8Array to a Base64 string for text transmission
            const base64 = btoa(String.fromCharCode.apply(null, compressed));
            return base64;
        }

        /**
         * Decodes and decompresses the data string from the QR code.
         * @param {string} base64Data Base64-encoded compressed JSON string.
         * @returns {object|null} The parsed data object or null on error.
         */
        function importDataFromJSON(base64Data) {
            try {
                // 1. Decode Base64 string to binary string
                const binaryString = atob(base64Data);
                // 2. Convert binary string to Uint8Array
                const binaryBytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
                // 3. Decompress using Pako
                const decompressed = pako.inflate(binaryBytes);
                // 4. Convert Uint8Array back to string
                const jsonString = new TextDecoder().decode(decompressed);
                // 5. Parse JSON
                return JSON.parse(jsonString);
            } catch (e) {
                console.error("Data import failed:", e);
                return null;
            }
        }

        window.showSyncModal = function(type) {
            if (type === 'export') {
                document.getElementById('sync-modal-title').textContent = "Export Data via QR Code (Source)";
                qrCodeContainerEl.innerHTML = '';
                const base64Data = exportDataToJSON();
                document.getElementById('sync-data-size').textContent = `${base64Data.length} characters`;

                if (base64Data.length > 0) {
                    new QRCode(qrCodeContainerEl, {
                        text: base64Data,
                        width: 200,
                        height: 200,
                        colorDark : "#000000",
                        colorLight : "#ffffff",
                        correctLevel : QRCode.CorrectLevel.H
                    });
                } else {
                    qrCodeContainerEl.innerHTML = '<p class="text-red-500">No data to export.</p>';
                }
            }
            syncModalEl.style.display = 'block';
        }

        window.hideSyncModal = function() {
            syncModalEl.style.display = 'none';
        }

        window.importSyncDataFromTextarea = function() {
            const syncDataText = document.getElementById('sync-import-area').value.trim();
            if (!syncDataText) {
                return displayError("Please paste the compressed data payload from the QR code into the text area.");
            }
            const importedData = importDataFromJSON(syncDataText);
            
            if (importedData && Array.isArray(importedData.vocab) && typeof importedData.progress === 'object') {
                vocabularyWords = importedData.vocab;
                wordProgress = importedData.progress;
                saveAllData();
                initializeFlashcardDeck();
                document.getElementById('sync-import-area').value = "";
                displayError(`‚úÖ Sync successful! Imported ${vocabularyWords.length} words and all progress data.`);
                setMode('flashcard');
            } else {
                displayError("‚ùå Sync failed. The pasted data is invalid, corrupted, or not in the correct compressed format.");
            }
        }


        // --- Settings / Dark Mode Logic ---
        function loadSettings() {
            try {
                const storedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
                userSettings = storedSettings ? JSON.parse(storedSettings) : defaultSettings;
            } catch (e) {
                console.error("Error loading settings, using default.", e);
                userSettings = defaultSettings;
            }
            applySettings();
        }

        function saveSettings() {
            // Read from DOM elements to update state before saving
            userSettings.darkMode = document.getElementById('dark-mode-toggle').checked;
            userSettings.swipeUp = document.getElementById('swipe-up-action').value;
            userSettings.swipeDown = document.getElementById('swipe-down-action').value;
            userSettings.includeEasyInQuiz = document.getElementById('include-easy-toggle').checked; 
            try {
                localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(userSettings));
            } catch (e) {
                displayError("Failed to save settings.");
            }
            applySettings();
        }

        function applySettings() {
            // Apply Dark Mode
            document.documentElement.setAttribute('data-theme', userSettings.darkMode ? 'dark' : 'light');
            document.getElementById('dark-mode-toggle').checked = userSettings.darkMode;
            document.getElementById('dark-mode-label').textContent = userSettings.darkMode ? 'Dark' : 'Light';
            
            // Apply new Quiz Setting (only if the element exists)
            if (document.getElementById('include-easy-toggle')) {
                document.getElementById('include-easy-toggle').checked = userSettings.includeEasyInQuiz;
            }

            // Apply Swipe Settings (only if the elements exist)
            if (document.getElementById('swipe-up-action')) {
                document.getElementById('swipe-up-action').value = userSettings.swipeUp;
            }
            if (document.getElementById('swipe-down-action')) {
                document.getElementById('swipe-down-action').value = userSettings.swipeDown;
            }
        }

        window.toggleDarkMode = function(isChecked) {
             userSettings.darkMode = isChecked;
             saveSettings();
        }
        
        window.toggleIncludeEasy = function(isChecked) {
            userSettings.includeEasyInQuiz = isChecked;
            saveSettings();
        }


        // --- Mobile Swiping Logic ---
        function handleTouchStart(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            // Set transition to none during the drag for immediate feedback
            flashcardEl.style.transition = 'none'; // ADDED for smoother drag
        }

        function handleTouchMove(e) {
            const touchCurrentX = e.changedTouches[0].screenX;
            const touchCurrentY = e.changedTouches[0].screenY;
            const dx = touchCurrentX - touchStartX;
            const dy = touchCurrentY - touchStartY;

            // Apply live translation to the card (dx * 0.5 makes the card drag feel less "sticky" or heavy)
            let transformValue = `translateX(${dx * 0.5}px) translateY(${dy * 0.5}px)`; // ADDED for live dragging
            
            // If the card is flipped, maintain the flipped state during translation
            if (flashcardEl.classList.contains('flipped')) { 
                transformValue += ' rotateY(180deg)'; 
            }

            flashcardEl.style.transform = transformValue; // MODIFIED to apply translation
            
            // Remove old classes
            flashcardEl.classList.remove('swiping-up', 'swiping-down', 'swiping-left', 'swiping-right');

            // Add new classes for visual cue (e.g., border color change)
            if (Math.abs(dy) > 10 || Math.abs(dx) > 10) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    flashcardEl.classList.add(dx > 0 ? 'swiping-right' : 'swiping-left');
                } else {
                    flashcardEl.classList.add(dy < 0 ? 'swiping-up' : 'swiping-down');
                }
            }
        }

        function handleTouchEnd(e) {
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            // Restore transition for smooth snap-back and flip
            flashcardEl.style.transition = 'transform 0.2s ease-out'; // MODIFIED for snap-back transition

            // Reset transform for snap-back
            if (flashcardEl.classList.contains('flipped')) { 
                flashcardEl.style.transform = 'rotateY(180deg)';
            } else {
                flashcardEl.style.transform = ''; 
            }

            flashcardEl.classList.remove('swiping-up', 'swiping-down', 'swiping-left', 'swiping-right');
            
            // 1. Check for Horizontal swipe (Navigation)
            if (Math.abs(dx) >= SWIPE_THRESHOLD && Math.abs(dx) > Math.abs(dy)) {
                if (dx < 0) {
                    navigateCard(1); // Swipe Left = Next
                    displayError("Navigated to **Next** word via Swipe Left.");
                } else {
                    navigateCard(-1); // Swipe Right = Previous
                    displayError("Navigated to **Previous** word via Swipe Right.");
                }
                e.stopPropagation();
            } 
            // 2. Check for Vertical swipe (Difficulty Marking)
            else if (Math.abs(dy) >= SWIPE_THRESHOLD && Math.abs(dy) > Math.abs(dx)) {
                if (dy < 0) { 
                    markDifficulty(userSettings.swipeUp);
                    displayError(`Marked as **${userSettings.swipeUp}** via Swipe Up.`);
                } else { 
                    markDifficulty(userSettings.swipeDown);
                    displayError(`Marked as **${userSettings.swipeDown}** via Swipe Down.`);
                }
                e.stopPropagation();
            }
        }

        function setupTouchListeners() {
            if (flashcardEl && !flashcardEl.dataset.touchListenersSetup) {
                // Changing to passive: false for touchmove and touchend to allow custom interaction/preventing default scroll if necessary, 
                // but relying primarily on the transform manipulation for smoothness.
                flashcardEl.addEventListener('touchstart', handleTouchStart, { passive: true });
                flashcardEl.addEventListener('touchmove', handleTouchMove, { passive: false });
                flashcardEl.addEventListener('touchend', handleTouchEnd, { passive: false });
                flashcardEl.dataset.touchListenersSetup = true;
            }
        }

        // --- Word Deck Management ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function initializeFlashcardDeck() {
            if (vocabularyWords.length === 0) {
                flashcardDeckIndices = [];
                currentWordIndex = 0;
                return;
            }
            flashcardDeckIndices = Array.from({ length: vocabularyWords.length }, (_, i) => i);
            shuffleArray(flashcardDeckIndices);
        }

        function renderCard() {
            if (vocabularyWords.length === 0) {
                cardWordEl.textContent = "No Vocabulary Loaded";
                cardMeaningEl.textContent = "Go to Word Manager to add words.";
                cardTagFrontEl.textContent = "";
                wrongCountEl.textContent = "";
                cardDeckStatusEl.textContent = "";
                return;
            }

            const actualVocabIndex = flashcardDeckIndices[currentWordIndex];
            const wordData = vocabularyWords[actualVocabIndex];
            const progress = wordProgress[wordData.word] || { wrongAttempts: 0, nextReviewDate: null, level: 'new' };

            cardWordEl.textContent = wordData.word;
            cardMeaningEl.textContent = wordData.meaning;
            cardTagFrontEl.textContent = wordData.tag ? wordData.tag.replace(/_/g, ' ') : 'General';
            cardDeckStatusEl.textContent = `Card ${currentWordIndex + 1} of ${flashcardDeckIndices.length} (Shuffled)`;

            let reviewText = "";
            if (progress.nextReviewDate) {
                reviewText = `Next Review: ${progress.nextReviewDate}`;
                if (isReviewDue(progress.nextReviewDate)) {
                    reviewText = `<span class="text-red-600 font-bold">DUE TODAY</span> | ${reviewText}`;
                }
            }
            
            wrongCountEl.innerHTML = (progress.wrongAttempts > 0 ? `<span class="text-red-500 font-semibold">Missed ${progress.wrongAttempts} time(s).</span>` : '') + (reviewText ? `<div class="text-xs text-gray-700 mt-1">${reviewText}</div>` : '');

            if (isFlipped) {
                flashcardEl.classList.remove('flipped');
                isFlipped = false;
            }
            updateDifficultyButtons(progress.level);
        }

        window.navigateCard = function(direction) {
            if (vocabularyWords.length === 0 || flashcardDeckIndices.length === 0) return;

            let newIndex = currentWordIndex + direction;

            if (newIndex >= flashcardDeckIndices.length) {
                initializeFlashcardDeck();
                displayError("üìö Flashcard cycle complete! The deck has been reshuffled for a fresh start.");
                currentWordIndex = 0;
            } else if (newIndex < 0) {
                currentWordIndex = flashcardDeckIndices.length - 1;
            } else {
                currentWordIndex = newIndex;
            }

            renderCard();
        }

        window.flipCard = function() {
            isFlipped = !isFlipped;
            flashcardEl.classList.toggle('flipped', isFlipped);
            if (flashcardEl.style.transition === 'none') {
                 flashcardEl.style.transition = 'transform 0.6s';
                 flashcardEl.style.transform = flashcardEl.classList.contains('flipped') ? 'rotateY(180deg)' : '';
            }
        }

        function updateDifficultyButtons(currentLevel) {
            Object.values(markButtons).forEach(btn => btn.classList.remove('selected', 'border-blue-500', 'ring-2', 'ring-offset-2'));
            const btn = markButtons[currentLevel];
            if (btn) {
                btn.classList.add('selected', 'border-blue-500', 'ring-2', 'ring-offset-2');
            }
        }
        
        window.markDifficulty = function(level) {
            if (vocabularyWords.length === 0 || flashcardDeckIndices.length === 0) return;
            
            const actualVocabIndex = flashcardDeckIndices[currentWordIndex];
            const wordData = vocabularyWords[actualVocabIndex];
            
            const nextReviewDate = getNextReviewDate(level);

            saveWordProgress(wordData.word, {
                level: level,
                nextReviewDate: nextReviewDate
            });

            // Automatically move to the next card after marking
            navigateCard(1); 
        }

        function getNextReviewDate(level) {
            const date = new Date();
            let days = 0;
            
            // SRS Logic
            if (level === 'easy') days = 7;
            else if (level === 'hard') days = 3;
            else if (level === 'superhard' || level === 'missed') days = 1; // Missed is treated as Super Hard in schedule

            date.setDate(date.getDate() + days);
            // Format as YYYY-MM-DD
            return date.toISOString().split('T')[0];
        }

        function isReviewDue(reviewDate) {
            if (!reviewDate) return true; // New words are always due

            const today = new Date().toISOString().split('T')[0];
            return reviewDate <= today;
        }
        
        // --- Quiz Logic ---
        window.setQuizType = function(type) {
            currentQuizType = type;
            const isRecognition = type === 'recognition';

            // Toggle Visibility
            document.getElementById('quiz-options').classList.toggle('hidden', !isRecognition);
            document.getElementById('recall-input-container').classList.toggle('hidden', isRecognition);
            quizMeaningRecallEl.classList.toggle('hidden', isRecognition);
            quizPromptRecallEl.classList.toggle('hidden', isRecognition);
            quizWordEl.classList.toggle('hidden', !isRecognition);

            // Reload word
            loadQuizWord();
        }

        function getQuizWords() {
            if (vocabularyWords.length === 0) return [];

            const eligibleWords = vocabularyWords.filter(wordData => {
                const progress = wordProgress[wordData.word] || { level: 'new' };
                // Filter out 'easy' words if the setting is disabled, unless they are newly added or missed.
                if (progress.level === 'easy' && !userSettings.includeEasyInQuiz && progress.wrongAttempts === 0) return false;
                
                return true; // Include new, hard, superhard, or easy if setting is on
            });
            
            // Prioritize words due for review or recently missed
            const dueAndMissedWords = eligibleWords.filter(wordData => {
                const progress = wordProgress[wordData.word] || { wrongAttempts: 0, nextReviewDate: null };
                const isMissed = progress.wrongAttempts > 0;
                const isDue = isReviewDue(progress.nextReviewDate);
                const isNew = progress.level === 'new';

                return isNew || isMissed || isDue;
            });
            
            // If there are words due/missed, use them. Otherwise, use all eligible words.
            const wordsToQuiz = (dueAndMissedWords.length > 0) ? dueAndMissedWords : eligibleWords;

            // Sort by superhard > hard > easy/new, then randomly
            return wordsToQuiz.sort((a, b) => {
                const levelA = wordProgress[a.word]?.level || 'new';
                const levelB = wordProgress[b.word]?.level || 'new';

                if (levelA === 'superhard' && levelB !== 'superhard') return -1;
                if (levelA !== 'superhard' && levelB === 'superhard') return 1;
                if (levelA === 'hard' && (levelB === 'easy' || levelB === 'new')) return -1;
                if ((levelA === 'easy' || levelA === 'new') && levelB === 'hard') return 1;
                
                return 0.5 - Math.random();
            });
        }

        function generateOptions(correctWord, allWords) {
            const correctMeaning = correctWord.meaning;
            const potentialWrongMeanings = Array.from(new Set(allWords 
                .filter(w => w.word !== correctWord.word) 
                .map(w => w.meaning)));
            
            // Select up to 3 random wrong meanings
            let wrongMeanings = potentialWrongMeanings 
                .sort(() => 0.5 - Math.random()) 
                .slice(0, 3);
            
            // Ensure we have 3 options total (1 correct + 2 wrong) if possible, filling with placeholders if needed
            while (wrongMeanings.length < 3 && vocabularyWords.length > 1) {
                const fillerMeaning = `A random meaning ${Math.random().toFixed(4)}`;
                if (!wrongMeanings.includes(fillerMeaning) && fillerMeaning !== correctMeaning) {
                    wrongMeanings.push(fillerMeaning);
                }
            }

            let options = [
                { meaning: correctMeaning, correct: true, id: 0 },
                ...wrongMeanings.map((m, i) => ({ meaning: m, correct: false, id: i + 1 }))
            ];
            
            return options.sort(() => 0.5 - Math.random());
        }

        window.loadQuizWord = function() {
            const quizWords = getQuizWords();
            const quizStatusEl = document.getElementById('quiz-status');
            nextQuizBtn.classList.add('hidden');
            
            const totalDue = quizWords.filter(w => isReviewDue(wordProgress[w.word]?.nextReviewDate)).length;
            const dueText = totalDue > 0 ? `<span class="text-red-600 font-bold">${totalDue} words DUE!</span>` : `No words currently due for review.`;
            quizStatusEl.innerHTML = `Quiz Progress: ${quizWords.length > 0 ? `1 of ${quizWords.length}` : '0 of 0'} (${dueText})`;


            if (quizWords.length === 0) {
                currentQuizWord = null;
                quizWordEl.textContent = vocabularyWords.length === 0 ? "No Vocabulary Loaded" : "Quiz Completed!";
                quizMeaningRecallEl.textContent = "";
                quizOptionsEl.innerHTML = "";
                recallInputEl.value = "";
                recallInputEl.disabled = true;
                recallCheckBtnEl.disabled = true;
                recallFeedbackEl.innerHTML = vocabularyWords.length === 0 ? "Go to Word Manager to add words." : "All due words reviewed. Restart the quiz to shuffle the deck.";

                if (vocabularyWords.length > 0) {
                     // Show a restart button instead of next
                     nextQuizBtn.textContent = "Restart Quiz";
                     nextQuizBtn.onclick = function() { 
                         // Re-initialize quiz (which calls getQuizWords and loads first word)
                         loadQuizWord(); 
                     };
                     nextQuizBtn.classList.remove('hidden');
                }
                updateQuizDueCount();
                return;
            }

            // Get the first word
            currentQuizWord = quizWords[0];

            if (currentQuizType === 'recognition') {
                // Recognition (MCQ)
                quizWordEl.textContent = currentQuizWord.word;
                quizOptionsEl.innerHTML = "";

                const options = generateOptions(currentQuizWord, vocabularyWords);

                options.forEach(option => {
                    const optionEl = document.createElement('div');
                    optionEl.className = 'quiz-option p-3 rounded-lg text-lg cursor-pointer hover:bg-gray-50 transition duration-150 shadow-sm dark:hover:bg-gray-600';
                    optionEl.textContent = option.meaning;
                    optionEl.dataset.correct = option.correct;
                    optionEl.onclick = () => checkRecognitionAnswer(optionEl, currentQuizWord.word);
                    quizOptionsEl.appendChild(optionEl);
                });

            } else {
                // Recall (Type In)
                quizMeaningRecallEl.textContent = currentQuizWord.meaning;
                recallInputEl.value = "";
                recallInputEl.disabled = false;
                recallCheckBtnEl.disabled = false;
                recallFeedbackEl.innerHTML = "";
            }
            nextQuizBtn.textContent = "Next Question ‚Üí";
            nextQuizBtn.onclick = loadQuizWord;
            
            // Remove the word that is currently being quizzed from the front of the array for the next round
            quizWords.shift(); 
        }

        // --- Answer Checking Logic ---
        function updateWordProgressAfterQuiz(word, isCorrect) {
            const currentProgress = wordProgress[word] || { wrongAttempts: 0, level: 'new' };
            if (isCorrect) {
                // If correct, mark as easy for immediate scheduling
                saveWordProgress(word, { 
                    wrongAttempts: 0, 
                    level: 'easy', 
                    nextReviewDate: getNextReviewDate('easy') 
                });
            } else {
                // If incorrect, mark as superhard/missed and reset review date to tomorrow
                const currentAttempts = (currentProgress.wrongAttempts || 0) + 1;
                saveWordProgress(word, { 
                    wrongAttempts: currentAttempts, 
                    level: 'superhard', 
                    nextReviewDate: getNextReviewDate('missed') // 'missed' schedule is 1 day
                });
            }
        }

        window.checkRecognitionAnswer = function(selectedEl, word) {
            const isCorrect = selectedEl.dataset.correct === 'true';

            // Disable all options
            Array.from(quizOptionsEl.children).forEach(el => {
                el.onclick = null;
                el.classList.remove('hover:bg-gray-50', 'dark:hover:bg-gray-600');
            });

            if (isCorrect) {
                selectedEl.classList.add('correct-answer', 'border-2');
            } else {
                selectedEl.classList.add('wrong-answer', 'border-2');
                const correctEl = Array.from(quizOptionsEl.children).find(el => el.dataset.correct === 'true');
                if (correctEl) correctEl.classList.add('correct-answer', 'border-2');
            }

            updateWordProgressAfterQuiz(word, isCorrect);
            nextQuizBtn.classList.remove('hidden');
        }

        window.checkRecallAnswer = function() {
            if (!currentQuizWord) return;

            const userAnswer = recallInputEl.value.trim().toLowerCase();
            const correctWord = currentQuizWord.word.trim().toLowerCase();
            const word = currentQuizWord.word;
            const isCorrect = userAnswer === correctWord;

            recallInputEl.disabled = true;
            recallCheckBtnEl.disabled = true;

            if (isCorrect) {
                recallFeedbackEl.innerHTML = `<span class="recall-result-correct font-bold">‚úÖ Correct!</span>`;
            } else {
                recallFeedbackEl.innerHTML = `
                    <span class="recall-result-wrong font-bold">‚ùå Wrong.</span> The correct word was: 
                    <span class="font-bold">${currentQuizWord.word}</span>.
                `;
            }

            updateWordProgressAfterQuiz(word, isCorrect);
            nextQuizBtn.classList.remove('hidden');
        }

        // --- Review Mode Logic ---
        window.filterReview = function(filter) {
            const reviewListEl = document.getElementById('review-list');
            const placeholderEl = document.getElementById('review-placeholder');
            reviewListEl.innerHTML = '';
            placeholderEl.classList.add('hidden');
            
            // Highlight active button
            document.getElementById('filter-hard').classList.remove('bg-yellow-200');
            document.getElementById('filter-superhard').classList.remove('bg-red-200');
            document.getElementById('filter-missed').classList.remove('bg-red-600');
            
            if (filter === 'hard') {
                document.getElementById('filter-hard').classList.add('bg-yellow-200');
            } else if (filter === 'superhard') {
                document.getElementById('filter-superhard').classList.add('bg-red-200');
            } else if (filter === 'missed') {
                document.getElementById('filter-missed').classList.add('bg-red-600');
            }


            let filteredWords = [];
            if (filter === 'missed') {
                filteredWords = vocabularyWords.filter(w => (wordProgress[w.word]?.wrongAttempts || 0) > 0);
            } else {
                filteredWords = vocabularyWords.filter(w => wordProgress[w.word]?.level === filter);
            }
            
            if (filteredWords.length === 0) {
                reviewListEl.innerHTML = `<p class="text-gray-500">No words currently tagged as '${filter.replace('superhard', 'Super Hard').replace('missed', 'Missed in Quiz')}'.</p>`;
                return;
            }

            filteredWords.forEach(wordData => {
                const progress = wordProgress[wordData.word];
                const item = document.createElement('div');
                item.className = 'p-3 bg-gray-50 rounded-lg flex justify-between items-center border border-gray-200 dark:bg-gray-700 dark:border-gray-600';
                
                let detailText = `Next Review: ${progress.nextReviewDate || 'N/A'}`;
                if (filter === 'missed') {
                    detailText = `Missed: ${progress.wrongAttempts} time(s)`;
                }

                item.innerHTML = `
                    <div class="truncate">
                        <span class="font-bold text-gray-900 dark:text-gray-100">${wordData.word}</span> 
                        <span class="text-gray-600 dark:text-gray-400 text-xs">(${wordData.tag || 'General'})</span>
                    </div>
                    <span class="text-xs font-medium text-blue-600 dark:text-blue-400">${detailText}</span>
                `;
                reviewListEl.appendChild(item);
            });
        }

        // --- Global Mode and UI Management ---
        window.setMode = function(mode) {
            currentMode = mode;
            document.getElementById('flashcard-mode').classList.add('hidden');
            document.getElementById('quiz-mode').classList.add('hidden');
            document.getElementById('review-mode').classList.add('hidden');
            document.getElementById('manage-mode').classList.add('hidden');
            document.getElementById('settings-mode').classList.add('hidden');

            document.getElementById(`${mode}-mode`).classList.remove('hidden');
            updateModeButtons();

            if (mode === 'flashcard') {
                renderCard();
            } else if (mode === 'quiz') {
                // Ensure correct quiz type is selected on mode switch
                const quizTypeRadios = document.getElementsByName('quiz_type');
                const selectedRadio = Array.from(quizTypeRadios).find(r => r.checked);
                currentQuizType = selectedRadio ? selectedRadio.value : 'recognition';
                setQuizType(currentQuizType);
            } else if (mode === 'manage') {
                totalWordsCountEl.textContent = vocabularyWords.length;
            } else if (mode === 'settings') {
                applySettings();
            }
        }

        function updateModeButtons() {
            Object.keys(modeButtons).forEach(mode => {
                if (mode === currentMode) {
                    modeButtons[mode].classList.add('bg-blue-600', 'text-white');
                    modeButtons[mode].classList.remove('bg-gray-200', 'text-gray-800', 'hover:bg-gray-300', 'dark:bg-gray-600', 'dark:text-gray-100', 'dark:hover:bg-gray-700');
                } else {
                    modeButtons[mode].classList.remove('bg-blue-600', 'text-white');
                    // Use theme-aware colors for non-selected buttons
                    modeButtons[mode].classList.add('bg-gray-200', 'text-gray-800', 'hover:bg-gray-300', 'dark:bg-gray-600', 'dark:text-gray-100', 'dark:hover:bg-gray-700');
                }
            });
        }

        // --- Data Loading and Saving ---
        function loadAllData() {
            try {
                const storedVocab = localStorage.getItem(VOCAB_STORAGE_KEY);
                const storedProgress = localStorage.getItem(PROGRESS_STORAGE_KEY);

                vocabularyWords = storedVocab ? JSON.parse(storedVocab) : [];
                wordProgress = storedProgress ? JSON.parse(storedProgress) : {};
            } catch (e) {
                console.error("Error loading data. Starting fresh.", e);
                vocabularyWords = [];
                wordProgress = {};
            }
            loadSettings(); // Load settings first
            initializeFlashcardDeck();
            updateQuizDueCount();
        }

        function saveAllData() {
            try {
                localStorage.setItem(VOCAB_STORAGE_KEY, JSON.stringify(vocabularyWords));
                localStorage.setItem(PROGRESS_STORAGE_KEY, JSON.stringify(wordProgress));
                totalWordsCountEl.textContent = vocabularyWords.length;
            } catch (e) {
                displayError("Failed to save data to local storage. Storage limit reached?");
            }
        }

        function saveWordProgress(word, data) {
            wordProgress[word] = { ...wordProgress[word], ...data };
            saveAllData();
            updateQuizDueCount();
        }

        // --- Data Deletion Logic ---
        window.showClearDataModal = function() {
            clearDataModalEl.style.display = 'block';
        }
        window.hideClearDataModal = function() {
            clearDataModalEl.style.display = 'none';
        }
        window.clearAllDataConfirmed = function() {
            localStorage.removeItem(VOCAB_STORAGE_KEY);
            localStorage.removeItem(PROGRESS_STORAGE_KEY);
            localStorage.removeItem(SETTINGS_STORAGE_KEY); // Clear settings too

            // Reset in-memory state
            vocabularyWords = [];
            wordProgress = {};
            currentWordIndex = 0;
            userSettings = defaultSettings; // Reset settings state

            hideClearDataModal();
            loadAllData(); // Re-initialize everything
            setMode('manage');
            displayError("All data has been successfully deleted from your browser's local storage.");
        }

        // --- UI Utility ---
        function displayError(message) {
            errorEl.innerHTML = message;
            errorEl.classList.remove('hidden', 'bg-red-100', 'border-red-400', 'text-red-700');
            errorEl.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
            setTimeout(() => errorEl.classList.add('hidden'), 5000);
        }

        function updateQuizDueCount() {
            const dueWords = getQuizWords().filter(w => isReviewDue(wordProgress[w.word]?.nextReviewDate));
            const count = dueWords.length;
            quizDueCountEl.textContent = count;
            if (count > 0) {
                quizDueCountEl.classList.remove('hidden');
            } else {
                quizDueCountEl.classList.add('hidden');
            }
        }

        // --- Word Import Logic ---
        window.addWordsFromJson = function() {
            const jsonText = document.getElementById('word-input-area').value.trim();
            if (!jsonText) {
                return displayError("Please paste a JSON array of words.");
            }

            try {
                const newWords = JSON.parse(jsonText);
                if (!Array.isArray(newWords) || newWords.length === 0) {
                    return displayError("Invalid JSON format. Expected a non-empty array of objects.");
                }

                const validNewWords = [];
                let duplicates = 0;
                const existingWordKeys = new Set(vocabularyWords.map(w => w.word.trim().toLowerCase()));

                for (const item of newWords) {
                    if (item.word && item.meaning) {
                        const word = item.word.trim();
                        const meaning = item.meaning.trim();
                        const tag = (item.tag || 'General').trim();

                        if (!existingWordKeys.has(word.toLowerCase())) {
                            validNewWords.push({ word, meaning, tag });
                            existingWordKeys.add(word.toLowerCase());
                        } else {
                            duplicates++;
                        }
                    }
                }

                if (validNewWords.length > 0) {
                    vocabularyWords = vocabularyWords.concat(validNewWords);
                    saveAllData();
                    initializeFlashcardDeck(); 
                    document.getElementById('word-input-area').value = "";
                    displayError(`Successfully added ${validNewWords.length} new words! ${duplicates > 0 ? `(${duplicates} duplicates skipped).` : ''}`);
                    totalWordsCountEl.textContent = vocabularyWords.length;
                } else if (duplicates > 0) {
                    displayError(`No new words added. All ${duplicates} words were duplicates.`);
                } else {
                    displayError("No valid words found in the input. Ensure each object has 'word' and 'meaning'.");
                }

            } catch (e) {
                console.error("JSON Parsing Error:", e);
                displayError("Error parsing JSON. Check the format carefully (e.g., must use double quotes for keys/strings).");
            }
        }

        // --- Initialization ---

        window.onload = () => {
            loadAllData();
            setupTouchListeners(); 

            if (vocabularyWords.length > 0) {
                setMode('flashcard');
            } else {
                 setMode('manage');
            }
            
            window.onclick = function(event) {
                if (event.target == clearDataModalEl) {
                    hideClearDataModal();
                }
                if (event.target == syncModalEl) {
                    hideSyncModal();
                }
            }
        };
    </script>
</body>
</html>
